#include <bits/stdc++.h>
#include <opencv2/opencv.hpp>
#include <iostream>
#include <chrono>
#include <thread>

using namespace std;
using namespace cv;

#define dbg(a) cerr << #a << ": " << a << "\n"

typedef struct{
    int imagesize_x, imagesize_y;
    int **pixel;
}image_t;

int displayImages(string leftImagePath, string disparityImagePath, string rightImagesPath) {
    dbg("displayImages");
    // Load images with desired color treatments
    cv::Mat image1 = cv::imread(leftImagePath, cv::IMREAD_COLOR);
    cv::Mat image2 = cv::imread(disparityImagePath, cv::IMREAD_GRAYSCALE);
    cv::Mat image3 = cv::imread(rightImagesPath, cv::IMREAD_COLOR);

    // Check if images are loaded successfully
    if (image1.empty() || image2.empty() || image3.empty()) {
        std::cerr << "Failed to load one or more images." << std::endl;
        return -1;
    }

    // Ensure all images have the same number of rows (height)
    int maxRows = std::max({image1.rows, image2.rows, image3.rows});
    int maxCols = image1.cols + image2.cols + image3.cols;

    // Resize images to match the maximum height
    cv::resize(image1, image1, cv::Size(maxCols / 3, maxRows));
    cv::resize(image2, image2, cv::Size(maxCols / 3, maxRows));
    cv::resize(image3, image3, cv::Size(maxCols / 3, maxRows));

    // Convert grayscale image to three channels
    cv::Mat image2Color;
    cv::cvtColor(image2, image2Color, cv::COLOR_GRAY2BGR);

    // Concatenate the images horizontally
    cv::Mat result;
    cv::hconcat(image1, image2Color, result);
    cv::hconcat(result, image3, result);

    // Display the concatenated image
    cv::imshow("Images", result);

    // Wait for a short duration to allow the window to update
    cv::waitKey(1);

    // Wait for 5 seconds
    std::this_thread::sleep_for(std::chrono::seconds(5));

    return 0;
}

// Convert opencv image to .pgm file
void savePGM(const cv::Mat& image, const std::string& filename) {

    std::ofstream file(filename, std::ios::out);

    if (!file.is_open()) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return;
    }

    // Write PGM header
    file << "P2\n";
    file << "# Created by OpenCV\n";
    file << image.cols << " " << image.rows << "\n";
    file << "255\n";  // Maximum pixel value

    // Write pixel values
    for (int i = 0; i < image.rows; ++i) {
        for (int j = 0; j < image.cols; ++j) {
            file << static_cast<int>(image.at<uchar>(i, j)) << " ";
        }
        file << "\n";
    }

    file.close();
}

// Convert image_t to .pgm file
void writePGMP2(const char *filename, const image_t *image) {
    FILE *file = fopen(filename, "w");
    if (file == NULL) {
        perror("Error opening file");
        exit(EXIT_FAILURE);
    }

    // Write PGM header
    fprintf(file, "P2\n");
    fprintf(file, "# Generated by your program\n");
    fprintf(file, "%d %d\n", image->imagesize_x, image->imagesize_y);
    fprintf(file, "255\n");

    // Write pixel data
    for (int y = 0; y < image->imagesize_y; ++y) {
        for (int x = 0; x < image->imagesize_x; ++x) {
            fprintf(file, "%d ", image->pixel[x][y]);
        }
        fprintf(file, "\n");
    }

    fclose(file);
}

void computeDisparity(image_t *leftImage, image_t *rightImage, image_t *disparityMap) {
    for (int y = 0; y < IMAGE_HEIGHT; ++y) {
        for (int x = 0; x < IMAGE_WIDTH; ++x) {
            int minDifference = 256;  // Initialize with a value higher than possible
            int bestDisparity = 0;

            for (int d = 0; d < MAX_DISPARITY; ++d) {
                int leftPixel = leftImage->pixel[x][y];
                if (x - d < 0)  continue;
                int rightPixel = rightImage->pixel[x - d][y];

                int difference = abs(leftPixel - rightPixel);
                if (difference < minDifference) {
                    minDifference = difference;
                    bestDisparity = d;
                }
            }

            disparityMap->pixel[x][y] = bestDisparity;
        }
    }
}



int processImages(cv::Mat leftImage, cv::Mat rightImage) {
    dbg("processImages");
    // Save in .png format
    imwrite("leftImage.png", leftImage);
    imwrite("rightImage.png", rightImage);

    // Save in .pgm format
    savePGM(leftImage, "leftImage.pgm");
    savePGM(rightImage, "rightImage.pgm");

    // Save in image struct
    image_t   image_left,image_right,image_disp;
    writePGMP2(leftImage.c_str(), image_left);
    writePGMP2(rightImage.c_str(), image_right);
    computeDisparity(image_left, image_right, image_disp)


    displayImages("leftImage.png", "leftImage.png", "rightImage.png");
    return 0;
}

int capture() {
    dbg("capture");
    // Open the first camera
    cv::VideoCapture cap1(0, CAP_V4L2);
    if (!cap1.isOpened()) {
        cerr << "Error opening camera 1." << endl;
        return -1;
    }

    // Open the second camera
    cv::VideoCapture cap2(2, CAP_V4L2);
    if (!cap2.isOpened()) {
        cerr << "Error opening camera 2." << endl;
        return -1;
    }

    int frameWidth = 450;
    int frameHeight = 375;
    cap1.set(cv::CAP_PROP_FRAME_WIDTH, frameWidth);
    cap1.set(cv::CAP_PROP_FRAME_HEIGHT, frameHeight);
    cap2.set(cv::CAP_PROP_FRAME_WIDTH, frameWidth);
    cap2.set(cv::CAP_PROP_FRAME_HEIGHT, frameHeight);

    while (true) {
        cv::Mat frame1, frame2;

        // Capture frame from camera 1
        cap1 >> frame1;
        if (frame1.empty()) {
            cerr << "Error capturing frame from camera 1." << endl;
            return -1;
        }

        // Capture frame from camera 2
        cap2 >> frame2;
        if (frame2.empty()) {
            cerr << "Error capturing frame from camera 2." << endl;
            return -1;
        }

        processImages(frame1, frame2);
    }
    return 0;
}

int main() {
    capture();
}

// clear && g++ main.cpp -std=c++11 `pkg-config --cflags --libs opencv4` && ./a.out
